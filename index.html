<html><head><base href=".">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<style>
  /* Clean modern styling */
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 20px;
    background: #f0f2f5;
  }

  .container {
    max-width: 900px;
    margin: 0 auto;
    background: transparent;
    padding: 0;
    box-shadow: none;
  }

  .chat-container {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    margin-bottom: 20px;
  }

  .welcome-screen {
    text-align: center;
    padding: 20px;
  }

  button {
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 5px;
    background: #0084ff;
    color: white;
    cursor: pointer;
    transition: background 0.3s;
    margin: 5px;
  }

  button:hover {
    background: #0066cc;
  }

  /* Add spinner styling for the button */
  .loading-spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
    margin-right: 8px;
    vertical-align: middle;
  }

  /* Style for disabled button */
  button:disabled {
    background: #cccccc;
    cursor: not-allowed;
    opacity: 0.7;
  }

  .chat-room {
    display: none;
  }

  .chat-messages {
    height: 400px;
    overflow-y: auto;
    border: 1px solid #ddd;
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 5px;
  }

  .message {
    margin: 5px 0;
    padding: 8px 12px;
    border-radius: 15px;
    max-width: 70%;
    word-wrap: break-word; /* Add this to wrap text */
    overflow-wrap: break-word; /* Add this for better word wrapping */
  }

  .system-message {
    background: #f0f0f0;
    color: #666;
    text-align: center;
    margin: 10px auto;
    padding: 5px 10px;
    border-radius: 5px;
    font-style: italic;
  }

  .join-request {
    background: #e3f2fd;
    padding: 10px;
    margin: 10px 0;
    border-radius: 5px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .accept {
    background: #4caf50;
  }

  .decline {
    background: #f44336;
  }

  .message-input {
    display: flex;
    gap: 10px;
  }

  .message-input input {
    flex: 1;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    outline: none; /* Remove default outline */
    transition: box-shadow 0.2s, border-color 0.2s; /* Smooth transition for focus effect */
  }

  .message-input input:focus {
    border-color: #0084ff;
    box-shadow: 0 0 0 2px rgba(0, 132, 255, 0.2); /* Add complete highlight around input */
  }

  .room-info {
    background: #e8f5e9;
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    font-family: monospace;
  }

  .waiting-screen {
    display: none;
    text-align: center;
    padding: 20px;
  }

  .spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 20px auto;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .file-upload {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 15px;
    padding: 15px;
    border: 2px dashed #ccc;
    border-radius: 8px;
    transition: all 0.3s ease;
  }

  /* Add this new style for drag hover state */
  .file-upload.drag-over {
    border-color: #0084ff;
    background: rgba(0, 132, 255, 0.1);
  }

  .file-upload-input-area {
    display: flex;
    flex-direction: column; /* Changed to column to stack buttons */
    gap: 15px;
    flex-wrap: wrap; /* Allow wrapping for smaller screens */
  }

  .custom-file-input {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #f5f5f5;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    flex: 1;
    min-width: 200px; /* Ensure minimum width */
    position: relative; /* Add this */
    overflow: hidden; /* Prevent content overflow */
    max-width: 100%; /* Ensure it doesn't exceed container width */
  }

  /* Update the file input positioning */
  .file-upload input[type="file"] {
    opacity: 0;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
    z-index: 1; /* Add this */
  }

  .custom-file-input span:first-of-type {
    flex: 0 1 auto;
    white-space: nowrap;
    padding-right: 15px; /* Space for separator */
    border-right: 1px solid #ccc; /* Vertical separator line */
  }

  .file-name-display {
    flex: 1;
    padding-left: 15px; /* Space after separator */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .public-chat {
    margin-top: 0;
    padding-top: 0;
  }

  .public-chat h2 {
    text-align: center;
    color: #333;
    margin: 0 0 20px 0; /* Changed to only have bottom margin */
    transition: max-height 0.3s ease-out;
    overflow: hidden;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px; /* Add spacing between text and icon */
  }

  /* Add these styles for the collapse indicator */
  .public-chat h2:after {
    content: '\f078'; /* Unicode for fas fa-chevron-down */
    font-family: 'Font Awesome 5 Free';
    font-weight: 900;
    margin-left: 10px;
    display: inline-block;
    transition: transform 0.3s ease;
  }

  .public-chat.collapsed h2:after {
    transform: rotate(-90deg);
  }

  /* Add margin removal when collapsed */
  .public-chat.collapsed h2 {
    margin: 0; /* Remove all margins when collapsed */
  }

  .public-chat.collapsed {
    max-height: 50px; /* Just enough to show the header */
  }

  .public-chat.collapsed .chat-messages,
  .public-chat.collapsed .message-input,
  .public-chat.collapsed .file-upload {
    display: none;
  }

  /* Add styling for images in messages */
  .message img {
    max-width: 100%; /* Make images responsive */
    height: auto; /* Maintain aspect ratio */
    border-radius: 5px; /* Optional: rounded corners for images */
    margin: 5px 0; /* Add some spacing around images */
  }

  /* Add styling for video elements */
  .message video {
    max-width: 100%; /* Make videos responsive */
    height: auto; /* Maintain aspect ratio */
    border-radius: 5px; /* Optional: rounded corners for videos */
    margin: 5px 0; /* Add some spacing around videos */
  }

  .message video:focus {
    outline: none; /* Remove focus outline */
  }

  /* Add styling for file links */
  .message .file-link {
    word-break: break-all; /* Allow long URLs to break */
    color: #0084ff;
    text-decoration: none;
  }

  .message .file-link:hover {
    text-decoration: underline;
  }

  /* Cancel upload button styles */
  .cancel-upload-btn {
    display: none; /* Hidden by default */
    width: 100%; /* Match width of send button */
    background: #ff4444; /* Red background */
    margin-top: 8px;
  }

  /* Add specific hover style for cancel upload button */
  .cancel-upload-btn:hover {
    background: #cc0000; /* Darker red on hover */
  }

  /* Make layout more responsive */
  @media (max-width: 600px), (max-width: 100%) {
    .file-upload-input-area {
      flex-direction: column;
      align-items: stretch;
    }
    
    .custom-file-input {
      flex-direction: column;
      align-items: stretch;
      text-align: center;
      padding: 12px 15px; /* Slightly larger padding on mobile */
    }

    .custom-file-input span:first-of-type {
      padding-right: 0;
      padding-bottom: 8px;
      border-right: none;
      border-bottom: 1px solid #ccc;
    }
    
    .file-name-display {
      padding-left: 0;
      padding-top: 8px;
    }
    
    .file-upload-input-area button {
      width: 100%;
      margin-top: 10px;
    }
  }

  /* Add this to your existing CSS */
  .upload-progress {
    width: 100%;
    background-color: #f0f0f0;
    border-radius: 4px;
    overflow: hidden;
    margin: 5px 0;
  }

  .progress-bar {
    width: 0%;
    height: 20px;
    background-color: #4CAF50;
    transition: width 0.3s ease;
    text-align: center;
    line-height: 20px;
    color: white;
    font-size: 12px;
  }

  .upload-message {
    font-style: italic;
    color: #666;
    margin: 5px 0;
  }

  .encryption-option {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 5px;
    font-size: 14px;
  }

  .encryption-option label {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #333;
  }

  .encryption-option .description {
    color: #666;
    font-size: 12px;
    margin-left: 25px; /* Aligns with text after checkbox */
    display: block;
  }

  /* New CSS for new messages indicator */
  .new-messages-indicator {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #0084ff;
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    display: none;
    z-index: 1000;
    animation: fadeIn 0.3s ease;
    font-size: 14px;
  }

  .new-messages-indicator:hover {
    background: #0066cc;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translate(-50%, 20px); }
    to { opacity: 1; transform: translate(-50%, 0); }
  }
</style>
</head>
<body>
  <div class="container">
    <div class="chat-container">
      <div class="welcome-screen" id="welcomeScreen">
        <h1>Welcome to Private Chat</h1>
        <button onclick="createRoom()">Create a Room</button>
        <button onclick="joinRoom()">Join a Room</button>
      </div>

      <div class="waiting-screen" id="waitingScreen">
        <h2>Waiting for approval...</h2>
        <div class="spinner"></div>
        <p>The room owner will review your request.</p>
      </div>

      <div class="chat-room" id="chatRoom">
        <div id="roomInfo" class="room-info"></div>
        <div class="chat-messages" id="chatMessages"></div>
        <div id="chatMessagesNewMessages" class="new-messages-indicator" onclick="scrollToBottom('chatMessages')">
          ↓ New messages below
        </div>
        <div class="message-input">
          <input type="text" id="messageInput" placeholder="Type your message...">
          <button onclick="sendMessage()">Send</button>
        </div>
        <div class="file-upload" id="fileUploadArea">
          <div class="file-upload-input-area">
            <label class="custom-file-input">
              <i class="fas fa-cloud-upload-alt"></i>
              <span>Choose file or drag &amp; drop</span>
              <span class="file-name-display" id="fileNameDisplay">No file selected</span>
              <input type="file" id="fileInput">
            </label>
            <button onclick="sendFile()">Send File</button>
            <button class="cancel-upload-btn">Cancel Upload (not working)</button>
            <div class="encryption-option">
              <label>
                <input type="checkbox" id="encryptFilePrivate">
                Encrypt Files
              </label>
              <span class="description">All files are sent securely by default. This option just adds another layer of protection so that websim.ai cannot as easily view your files.</span>
            </div>
            <div class="encryption-option">
              <label>
                <input type="checkbox" id="cloakFilePrivate">
                File Cloaker
              </label>
              <span class="description">Disguise files by making them appear as generic binary files during transmission.</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="chat-container">
      <div class="public-chat">
        <h2>Public Chat Room</h2>
        <div class="chat-messages" id="publicChatMessages"></div>
        <div id="publicChatMessagesNewMessages" class="new-messages-indicator" onclick="scrollToBottom('publicChatMessages')" style="position: relative; margin-bottom: 10px; text-align: center;">
          New Messages Below
        </div>
        <div class="message-input">
          <input type="text" id="publicMessageInput" placeholder="Type your message...">
          <button onclick="sendPublicMessage()">Send</button>
        </div>
        <div class="file-upload" id="publicFileUploadArea">
          <div class="file-upload-input-area">
            <label class="custom-file-input">
              <i class="fas fa-cloud-upload-alt"></i>
              <span>Choose file or drag &amp; drop</span>  
              <span class="file-name-display" id="publicFileNameDisplay">No file selected</span>
              <input type="file" id="publicFileInput">
            </label>
            <button onclick="sendPublicFile()">Send File</button>
            <button class="cancel-upload-btn">Cancel Upload (not working)</button>
            <div class="encryption-option">
              <label>
                <input type="checkbox" id="encryptFilePublic">
                Encrypt Files
              </label>
              <span class="description">All files are sent securely by default. This option just adds another layer of protection so that websim.ai cannot as easily view your files.</span>
            </div>
            <div class="encryption-option">
              <label>
                <input type="checkbox" id="cloakFilePublic">
                File Cloaker
              </label>
              <span class="description">Disguise files by making them appear as generic binary files during transmission.</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
function isScrolledToBottom(element) {
  // Allow for 1px difference due to rounding
  return Math.abs(element.scrollHeight - element.clientHeight - element.scrollTop) < 1;
}

const state = {
  room: null,
  isOwner: false,
  roomCode: '',
  roomMembers: new Set(),
  pendingRequests: new Map() // Maps clientId to username
};

async function deriveKey(key) {
  const rawKey = new TextEncoder().encode(key.padEnd(32, "0")); // Ensure 32 bytes for AES-256
  return await crypto.subtle.importKey(
    "raw",
    rawKey,
    { name: "AES-GCM" },
    false,
    ["encrypt", "decrypt"]
  );
}

async function encryptFile(file, key) {
  const cryptoKey = await deriveKey(key);
  const iv = crypto.getRandomValues(new Uint8Array(12)); // 12-byte IV for AES-GCM
  const fileData = await file.arrayBuffer();

  const encryptedData = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    cryptoKey,
    fileData
  );

  // Combine IV and encrypted data
  const combinedData = new Uint8Array(iv.byteLength + encryptedData.byteLength);
  combinedData.set(iv);
  combinedData.set(new Uint8Array(encryptedData), iv.byteLength);

  return combinedData;
}

async function decryptFile(encryptedData, key) {
  const cryptoKey = await deriveKey(key);
  
  // Extract IV from start of data (first 12 bytes)
  const iv = encryptedData.slice(0, 12);
  const data = encryptedData.slice(12);

  try {
    const decryptedData = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      cryptoKey,
      data
    );
    return decryptedData;
  } catch (error) {
    console.error('Decryption failed:', error);
    throw error;
  }
}

function initializeRoom() {
  state.room = new WebsimSocket();
  
  state.room.onmessage = (event) => {
    const data = event.data;
    console.log('Received message:', data);

    switch(data.type) {
      case 'joinRequest':
        if (state.isOwner) {
          handleJoinRequest(data);
        }
        break;

      case 'approvalMessage':
        if (data.roomCode === state.roomCode) {
          handleApprovalMessage(data);
        }
        break;

      case 'chatMessage':
        if (data.roomCode === state.roomCode) {
          displayMessage(data); // This function is now defined
        }
        break;

      case 'fileMessage':
        if (data.roomCode === state.roomCode) {
          displayFileMessage(data);
        }
        break;

      case 'connected':
        addSystemMessage(`${data.username} connected to websim`);
        break;

      case 'disconnected':
        if (state.roomMembers.has(data.clientId)) {
          state.roomMembers.delete(data.clientId);
          addSystemMessage(`${data.username} left the chat`);
        }
        break;
        
      case 'uploadStart':
        if (data.clientId !== state.room.party.client.id) {
          const messages = document.getElementById('chatMessages');
          const wasAtBottom = isScrolledToBottom(messages);
          
          const progressMessage = document.createElement('div');
          progressMessage.className = 'message';
          progressMessage.style.backgroundColor = '#f5f5f5';
          progressMessage.style.marginLeft = '0';
          
          progressMessage.innerHTML = `
            <strong>${data.username}</strong><br>
            <div class="upload-message">Uploading: ${data.fileName}</div>
            <div class="upload-progress">
              <div class="progress-bar" style="width: 0%">0%</div>
            </div>
          `;
          
          messages.appendChild(progressMessage);
          
          if (wasAtBottom) {
            messages.scrollTop = messages.scrollHeight;
          }
          
          // Simulate progress for other users
          const progressBar = progressMessage.querySelector('.progress-bar');
          const progressInterval = setInterval(() => {
            const currentWidth = parseInt(progressBar.style.width) || 0;
            if (currentWidth < 90) {
              const newWidth = currentWidth + Math.random() * 20;
              progressBar.style.width = `${newWidth}%`;
              progressBar.textContent = `${Math.round(newWidth)}%`;
            } else {
              clearInterval(progressInterval);
            }
          }, 500);
          
          // Store interval ID to clear it when file message arrives
          progressMessage.dataset.progressInterval = progressInterval;
          progressMessage.dataset.fileName = data.fileName;
        }
        break;
    }
  };

  state.roomMembers.add(state.room.party.client.id);
}

let publicRoom;

// Initialize public chat when page loads
window.addEventListener('load', initializePublicChat);

function initializePublicChat() {
  publicRoom = new WebsimSocket();
  
  publicRoom.onmessage = (event) => {
    const data = event.data;
    
    switch(data.type) {
      case 'publicMessage':
        displayPublicMessage(data);
        break;
        
      case 'publicFileMessage':
        displayPublicFileMessage(data);
        break;
        
      case 'connected':
        addPublicSystemMessage(`${data.username} connected to public chat`);
        break;
        
      case 'disconnected':
        addPublicSystemMessage(`${data.username} left public chat`);
        break;

      case 'uploadStart':
        if (data.clientId !== publicRoom.party.client.id) {
          const messages = document.getElementById('publicChatMessages');  
          const wasAtBottom = isScrolledToBottom(messages);
          
          const progressMessage = document.createElement('div');
          progressMessage.className = 'message';
          progressMessage.style.backgroundColor = '#f5f5f5';
          progressMessage.style.marginLeft = '0';
          
          progressMessage.innerHTML = `
            <strong>${data.username}</strong><br>
            <div class="upload-message">Uploading: ${data.fileName}</div>
            <div class="upload-progress">
              <div class="progress-bar" style="width: 0%">0%</div>
            </div>
          `;
          
          messages.appendChild(progressMessage);
          
          if (wasAtBottom) {
            messages.scrollTop = messages.scrollHeight;
          }
          
          // Simulate progress for other users
          const progressBar = progressMessage.querySelector('.progress-bar');
          const progressInterval = setInterval(() => {
            const currentWidth = parseInt(progressBar.style.width) || 0;
            if (currentWidth < 90) {
              const newWidth = currentWidth + Math.random() * 20;
              progressBar.style.width = `${newWidth}%`;
              progressBar.textContent = `${Math.round(newWidth)}%`;
            } else {
              clearInterval(progressInterval);
            }
          }, 500);
          
          // Store interval ID to clear it when file message arrives
          progressMessage.dataset.progressInterval = progressInterval;
          progressMessage.dataset.fileName = data.fileName;
        }
        break;
    }
  };
}

function initializeFileUploads() {
  // Setup private chat file upload
  setupFileUpload('fileUploadArea', 'fileInput', 'fileNameDisplay');
  
  // Setup public chat file upload
  setupFileUpload('publicFileUploadArea', 'publicFileInput', 'publicFileNameDisplay');
}

function setupFileUpload(areaId, inputId, displayId) {
  const uploadArea = document.getElementById(areaId);
  const fileInput = document.getElementById(inputId);
  const fileDisplay = document.getElementById(displayId);

  // Dragover handler - add highlight
  uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('drag-over');
  });

  // Dragleave handler - remove highlight
  uploadArea.addEventListener('dragleave', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('drag-over');
  });

  // Drop handler - remove highlight and process files
  uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('drag-over');
    
    if (e.dataTransfer.files.length) {
      fileInput.files = e.dataTransfer.files;
      updateFileName(fileInput, fileDisplay);
    }
  });

  // Keep existing file input change handler
  fileInput.addEventListener('change', () => {
    updateFileName(fileInput, fileDisplay);
  });
}

function updateFileName(input, display) {
  if (input.files.length > 0) {
    display.textContent = input.files[0].name;
  } else {
    display.textContent = 'No file selected';
  }
}

// Add this function near the other initialization functions
function initializePublicChatCollapse() {
  const publicChatSection = document.querySelector('.public-chat');
  const publicChatHeader = publicChatSection.querySelector('h2');
  
  publicChatHeader.addEventListener('click', () => {
    publicChatSection.classList.toggle('collapsed');
  });
}

// Add this to window load event handler
window.addEventListener('load', () => {
  initializePublicChat();
  initializeFileUploads();
  initializePublicChatCollapse(); // Add this line
  initializeChatScrolling(); // Add this line
});

function initializeChatScrolling() {
  const chatMessages = document.getElementById('chatMessages');
  const publicChatMessages = document.getElementById('publicChatMessages');
  
  chatMessages.addEventListener('scroll', () => {
    if (isScrolledToBottom(chatMessages)) {
      document.getElementById('chatMessagesNewMessages').style.display = 'none';
    }
  });
  
  publicChatMessages.addEventListener('scroll', () => {
    if (isScrolledToBottom(publicChatMessages)) {
      document.getElementById('publicChatMessagesNewMessages').style.display = 'none';
    }
  });
}

async function sendPublicFile() {
  const fileInput = document.getElementById('publicFileInput');
  const sendButton = fileInput.parentElement.nextElementSibling;
  const shouldEncrypt = document.getElementById('encryptFilePublic').checked;
  const shouldCloak = document.getElementById('cloakFilePublic').checked;
  const file = fileInput.files[0];
  
  if (!file) {
    alert('Please select a file first');
    return;
  }

  const messages = document.getElementById('publicChatMessages');
  const wasAtBottom = isScrolledToBottom(messages);
  
  // Create progress message in chat
  const progressMessage = document.createElement('div');
  progressMessage.className = 'message';
  progressMessage.style.backgroundColor = '#e3f2fd';
  progressMessage.style.marginLeft = 'auto';
  
  progressMessage.innerHTML = `
    <strong>${publicRoom.party.client.username} (you)</strong><br>
    <div class="upload-message">Uploading: ${file.name}${shouldEncrypt ? ' (Encrypted)' : ''}${shouldCloak ? ' (Cloaked)' : ''}</div>
    <div class="upload-progress">
      <div class="progress-bar" style="width: 0%">0%</div>
    </div>
  `;

  messages.appendChild(progressMessage);
  if (wasAtBottom) {
    messages.scrollTop = messages.scrollHeight;
  }

  // Broadcast upload start to other users
  publicRoom.send({
    type: 'uploadStart',
    fileName: file.name + (shouldEncrypt ? ' (Encrypted)' : '') + (shouldCloak ? ' (Cloaked)' : ''),
    clientId: publicRoom.party.client.id,
    username: publicRoom.party.client.username,
    timestamp: Date.now()
  });

  try {
    sendButton.disabled = true;
    sendButton.innerHTML = '<span class="loading-spinner"></span>Sending...';
    
    // Simulate progress updates
    const progressBar = progressMessage.querySelector('.progress-bar');
    const progressInterval = setInterval(() => {
      const currentWidth = parseInt(progressBar.style.width) || 0;
      if (currentWidth < 90) {
        const newWidth = currentWidth + Math.random() * 20;
        progressBar.style.width = `${newWidth}%`;
        progressBar.textContent = `${Math.round(newWidth)}%`;
      }
    }, 500);

    let fileToUpload = file;
    let originalFileName = file.name;
    let originalFileType = file.type;

    // Handle encryption and cloaking
    if (shouldEncrypt) {
      const encryptedData = await encryptFile(file, 'abcd123');
      fileToUpload = new File([encryptedData], file.name + '.enc', { type: 'application/octet-stream' });
    }
    
    // Apply cloaking after encryption if requested
    if (shouldCloak) {
      fileToUpload = new File([fileToUpload], fileToUpload.name + '.bin', { type: 'application/octet-stream' });
    }
    
    const url = await websim.upload(fileToUpload);
    
    clearInterval(progressInterval);
    progressBar.style.width = '100%';
    progressBar.textContent = '100%';
    
    progressMessage.remove();
    
    publicRoom.send({
      type: 'publicFileMessage',
      fileUrl: url,
      fileName: originalFileName,
      fileType: originalFileType,
      encrypted: shouldEncrypt,
      cloaked: shouldCloak,
      clientId: publicRoom.party.client.id,
      username: publicRoom.party.client.username,
      timestamp: Date.now()
    });

    fileInput.value = '';
    updateFileName(fileInput, document.getElementById('publicFileNameDisplay'));
  } catch (error) {
    console.error('Error uploading file:', error);
    progressMessage.innerHTML = `
      <strong>${publicRoom.party.client.username} (you)</strong><br>
      <div class="upload-message" style="color: #f44336;">Upload failed: ${file.name}</div>
    `;
    alert('Failed to upload file. Please try again.');
  } finally {
    sendButton.disabled = false;
    sendButton.textContent = 'Send File';
  }
}

async function sendFile() {
  const fileInput = document.getElementById('fileInput');
  const sendButton = fileInput.parentElement.nextElementSibling;
  const shouldEncrypt = document.getElementById('encryptFilePrivate').checked;
  const shouldCloak = document.getElementById('cloakFilePrivate').checked;
  const file = fileInput.files[0];
  
  if (!file) {
    alert('Please select a file first');
    return;
  }

  const messages = document.getElementById('chatMessages');
  const wasAtBottom = isScrolledToBottom(messages);
  
  const progressMessage = document.createElement('div');
  progressMessage.className = 'message';
  progressMessage.style.backgroundColor = '#f5f5f5';
  progressMessage.style.marginLeft = '0';
  
  progressMessage.innerHTML = `
    <strong>${state.room.party.client.username} (you)</strong><br>
    <div class="upload-message">Uploading: ${file.name}${shouldEncrypt ? ' (Encrypted)' : ''}${shouldCloak ? ' (Cloaked)' : ''}</div>
    <div class="upload-progress">
      <div class="progress-bar" style="width: 0%">0%</div>
    </div>
  `;

  messages.appendChild(progressMessage);
  if (wasAtBottom) {
    messages.scrollTop = messages.scrollHeight;
  }

  try {
    sendButton.disabled = true;
    sendButton.innerHTML = '<span class="loading-spinner"></span>Sending...';

    let fileToUpload = file;
    let originalFileName = file.name;
    let originalFileType = file.type;

    // Handle encryption and cloaking
    if (shouldEncrypt) {
      const encryptedData = await encryptFile(file, 'abcd123');
      fileToUpload = new File([encryptedData], file.name + '.enc', { type: 'application/octet-stream' });
    }
    
    // Apply cloaking after encryption if requested
    if (shouldCloak) {
      fileToUpload = new File([fileToUpload], fileToUpload.name + '.bin', { type: 'application/octet-stream' });
    }
    
    const url = await websim.upload(fileToUpload);
    
    state.room.send({
      type: 'fileMessage',
      fileUrl: url,
      fileName: originalFileName,
      fileType: originalFileType,
      encrypted: shouldEncrypt,
      cloaked: shouldCloak,
      roomCode: state.roomCode,
      clientId: state.room.party.client.id,
      username: state.room.party.client.username,
      timestamp: Date.now()
    });

    fileInput.value = '';
    updateFileName(fileInput, document.getElementById('fileNameDisplay'));
  } catch (error) {
    console.error('Error uploading file:', error);
    alert('Failed to upload file. Please try again.');
  } finally {
    sendButton.disabled = false;
    sendButton.textContent = 'Send File';
  }
}

async function displayPublicFileMessage(data) {
  const messages = document.getElementById('publicChatMessages');
  const wasAtBottom = isScrolledToBottom(messages);
  
  // Remove existing progress messages...
  const progressMessages = messages.querySelectorAll('.message');
  progressMessages.forEach(msg => {
    if (msg.dataset.fileName === data.fileName + (data.encrypted ? ' (Encrypted)' : '') + (data.cloaked ? ' (Cloaked)' : '')) {
      if (msg.dataset.progressInterval) {
        clearInterval(parseInt(msg.dataset.progressInterval));
      }
      msg.remove();
    }
  });

  const messageDiv = document.createElement('div');
  messageDiv.className = 'message';

  const isOwnMessage = data.clientId === publicRoom.party.client.id;
  messageDiv.style.backgroundColor = isOwnMessage ? '#e3f2fd' : '#f5f5f5';
  messageDiv.style.marginLeft = isOwnMessage ? 'auto' : '0';

  const displayName = isOwnMessage ? `${data.username} (you)` : data.username;
  const timestamp = new Date(data.timestamp).toLocaleTimeString();

  const securityIcons = [];
  if (data.encrypted) {
    securityIcons.push('<i class="fas fa-lock" style="color: #4CAF50; margin-left: 5px;"></i>');
  }
  if (data.cloaked) {
    securityIcons.push('<i class="fas fa-mask" style="color: #4CAF50; margin-left: 5px;"></i>');
  }
  const securityStatus = securityIcons.join('');

  // Add loading message while decrypting
  messageDiv.innerHTML = `
    <strong>${displayName}</strong> <span style="color: #666; font-size: 0.8em;">${timestamp}</span><br>
    ${data.encrypted ? 'Decrypting file...' : 'Processing file...'} ${securityStatus}
  `;
  messages.appendChild(messageDiv);
  if (wasAtBottom) {
    messages.scrollTop = messages.scrollHeight;
  }

  try {
    let fileUrl = data.fileUrl;
    let fileType = data.fileType;

    // Handle decryption if needed
    if (data.encrypted) {
      const response = await fetch(data.fileUrl);
      const encryptedData = await response.arrayBuffer();
      const decryptedData = await decryptFile(new Uint8Array(encryptedData), 'abcd123');
      const blob = new Blob([decryptedData], { type: data.fileType });
      fileUrl = URL.createObjectURL(blob);
    }

    let fileContent = '';
    if (data.fileType.startsWith('image/')) {
      fileContent = `<img src="${fileUrl}" alt="Shared image" onload="if(${wasAtBottom}) document.getElementById('publicChatMessages').scrollTop = document.getElementById('publicChatMessages').scrollHeight;">`;
    } else if (data.fileType.startsWith('video/')) {
      fileContent = `
        <video controls style="max-width: 100%; height: auto;">
          <source src="${fileUrl}" type="${fileType}">
          Your browser does not support the video tag.
        </video>`;
    } else {
      fileContent = `<a href="${fileUrl}" target="_blank" class="file-link">${data.fileName}</a>`;
    }

    messageDiv.innerHTML = `
      <strong>${displayName}</strong> <span style="color: #666; font-size: 0.8em;">${timestamp}</span><br>
      Shared a file ${securityStatus}<br>
      ${fileContent}
    `;

    if (wasAtBottom) {
      messages.scrollTop = messages.scrollHeight;
    }

  } catch (error) {
    console.error('Error processing file:', error);
    messageDiv.innerHTML = `
      <strong>${displayName}</strong> <span style="color: #666; font-size: 0.8em;">${timestamp}</span><br>
      Error processing file ${securityStatus}<br>
      <span style="color: red;">Failed to ${data.encrypted ? 'decrypt' : 'process'} file: ${data.fileName}</span>
    `;
  }

  if (wasAtBottom) {
    messages.scrollTop = messages.scrollHeight;
  }
}

async function displayFileMessage(data) {
  const messages = document.getElementById('chatMessages');
  const wasAtBottom = isScrolledToBottom(messages);
  
  // Remove existing progress messages...
  const progressMessages = messages.querySelectorAll('.message');
  progressMessages.forEach(msg => {
    if (msg.dataset.fileName === data.fileName + (data.encrypted ? ' (Encrypted)' : '') + (data.cloaked ? ' (Cloaked)' : '')) {
      if (msg.dataset.progressInterval) {
        clearInterval(parseInt(msg.dataset.progressInterval));
      }
      msg.remove();
    }
  });

  const messageDiv = document.createElement('div');
  messageDiv.className = 'message';

  const isOwnMessage = data.clientId === state.room.party.client.id;
  messageDiv.style.backgroundColor = isOwnMessage ? '#e3f2fd' : '#f5f5f5';
  messageDiv.style.marginLeft = isOwnMessage ? 'auto' : '0';

  const displayName = isOwnMessage ? `${data.username} (you)` : data.username;
  const timestamp = new Date(data.timestamp).toLocaleTimeString();
  
  const securityIcons = [];
  if (data.encrypted) {
    securityIcons.push('<i class="fas fa-lock" style="color: #4CAF50; margin-left: 5px;"></i>');
  }
  if (data.cloaked) {
    securityIcons.push('<i class="fas fa-mask" style="color: #4CAF50; margin-left: 5px;"></i>');
  }
  const securityStatus = securityIcons.join('');

  // Add loading message while decrypting
  messageDiv.innerHTML = `
    <strong>${displayName}</strong> <span style="color: #666; font-size: 0.8em;">${timestamp}</span><br>
    ${data.encrypted ? 'Decrypting file...' : 'Processing file...'} ${securityStatus}
  `;
  messages.appendChild(messageDiv);
  if (wasAtBottom) {
    messages.scrollTop = messages.scrollHeight;
  } else {
    showNewMessagesIndicator('chatMessages');
  }

  try {
    let fileUrl = data.fileUrl;
    let fileType = data.fileType;

    // Handle decryption if needed
    if (data.encrypted) {
      const response = await fetch(data.fileUrl);
      const encryptedData = await response.arrayBuffer();
      const decryptedData = await decryptFile(new Uint8Array(encryptedData), 'abcd123');
      const blob = new Blob([decryptedData], { type: data.fileType });
      fileUrl = URL.createObjectURL(blob);
    }

    let fileContent = '';
    if (data.fileType.startsWith('image/')) {
      fileContent = `<img src="${fileUrl}" alt="Shared image" onload="if(${wasAtBottom}) document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;">`;
    } else if (data.fileType.startsWith('video/')) {
      fileContent = `
        <video controls style="max-width: 100%; height: auto;">
          <source src="${fileUrl}" type="${fileType}">
          Your browser does not support the video tag.
        </video>`;
    } else {
      fileContent = `<a href="${fileUrl}" target="_blank" class="file-link">${data.fileName}</a>`;
    }

    messageDiv.innerHTML = `
      <strong>${displayName}</strong> <span style="color: #666; font-size: 0.8em;">${timestamp}</span><br>
      Shared a file ${securityStatus}<br>
      ${fileContent}
    `;

    if (wasAtBottom) {
      messages.scrollTop = messages.scrollHeight;
    }

  } catch (error) {
    console.error('Error processing file:', error);
    messageDiv.innerHTML = `
      <strong>${displayName}</strong> <span style="color: #666; font-size: 0.8em;">${timestamp}</span><br>
      Error processing file ${securityStatus}<br>
      <span style="color: red;">Failed to ${data.encrypted ? 'decrypt' : 'process'} file: ${data.fileName}</span>
    `;
  }

  if (wasAtBottom) {
    messages.scrollTop = messages.scrollHeight;
  }
}

function createRoom() {
  state.roomCode = Math.random().toString(36).substring(2, 8).toUpperCase();
  state.isOwner = true;
  initializeRoom();

  document.getElementById('welcomeScreen').style.display = 'none';
  document.getElementById('chatRoom').style.display = 'block';
  document.getElementById('roomInfo').innerHTML = `Room Code: ${state.roomCode} (Owner)`;
  addSystemMessage('Room created! Share the code with others to let them join.');
  
  // Collapse public chat when room is created
  document.querySelector('.public-chat').classList.add('collapsed');
}

function joinRoom() {
  const code = prompt("Enter room code:");
  if (!code) return;

  state.roomCode = code.toUpperCase();
  state.isOwner = false;
  initializeRoom();

  document.getElementById('welcomeScreen').style.display = 'none';
  document.getElementById('waitingScreen').style.display = 'block';

  state.room.send({
    type: 'joinRequest',
    roomCode: state.roomCode,
    clientId: state.room.party.client.id,
    username: state.room.party.client.username
  });
}

function handleJoinRequest(data) {
  if (data.roomCode !== state.roomCode || 
      state.roomMembers.has(data.clientId) || 
      state.pendingRequests.has(data.clientId)) {
    return;
  }

  state.pendingRequests.set(data.clientId, data.username);

  const requestDiv = document.createElement('div');
  requestDiv.className = 'join-request';
  requestDiv.setAttribute('data-client-id', data.clientId);
  requestDiv.innerHTML = `
    <span>${data.username} wants to join the room</span>
    <div>
      <button class="accept" onclick="approveUser('${data.clientId}')">Accept</button>
      <button class="decline" onclick="declineUser('${data.clientId}')">Decline</button>
    </div>
  `;
  document.getElementById('chatMessages').appendChild(requestDiv);
}

function approveUser(clientId) {
  if (!state.pendingRequests.has(clientId)) return;

  const username = state.pendingRequests.get(clientId);
  state.pendingRequests.delete(clientId);

  const requestDiv = document.querySelector(`.join-request[data-client-id="${clientId}"]`);
  if (requestDiv) requestDiv.remove();

  state.room.send({
    type: 'approvalMessage',
    roomCode: state.roomCode,
    approved: true,
    targetClientId: clientId,
    username: username
  });

  state.roomMembers.add(clientId);
  addSystemMessage(`${username} has joined the room.`);
}

function declineUser(clientId) {
  if (!state.pendingRequests.has(clientId)) return;

  const username = state.pendingRequests.get(clientId);
  state.pendingRequests.delete(clientId);

  const requestDiv = document.querySelector(`.join-request[data-client-id="${clientId}"]`);
  if (requestDiv) requestDiv.remove();

  state.room.send({
    type: 'approvalMessage',
    roomCode: state.roomCode,
    approved: false,
    targetClientId: clientId,
    username: username
  });

  addSystemMessage(`${username}'s request was declined.`);
}

function handleApprovalMessage(data) {
  if (data.targetClientId === state.room.party.client.id) {
    if (data.approved) {
      document.getElementById('waitingScreen').style.display = 'none';
      document.getElementById('chatRoom').style.display = 'block';
      document.getElementById('roomInfo').innerHTML = `Room Code: ${state.roomCode}`;
      state.roomMembers.add(state.room.party.client.id);
      addSystemMessage("You've been accepted into the room!");
      
      // Collapse public chat when joining room is approved
      document.querySelector('.public-chat').classList.add('collapsed');
    } else {
      document.getElementById('waitingScreen').style.display = 'none';
      document.getElementById('welcomeScreen').style.display = 'block';
      alert("Your join request was declined.");
    }
  }
}

function sendMessage() {
  const input = document.getElementById('messageInput');
  const message = input.value.trim();

  if (message && state.room) { // Check if room exists
    state.room.send({
      type: 'chatMessage',
      message: message,
      roomCode: state.roomCode,
      clientId: state.room.party.client.id,
      username: state.room.party.client.username,
      timestamp: Date.now()
    });
    input.value = '';
  }
}

function sendPublicMessage() {
  const input = document.getElementById('publicMessageInput');
  const message = input.value.trim();

  if (message && publicRoom) { // Check if publicRoom exists
    publicRoom.send({
      type: 'publicMessage',
      message: message,
      clientId: publicRoom.party.client.id,
      username: publicRoom.party.client.username,
      timestamp: Date.now()
    });
    input.value = '';
  }
}

function addSystemMessage(message) {
  const messagesDiv = document.getElementById('chatMessages');
  const messageDiv = document.createElement('div');
  messageDiv.className = 'system-message';
  messageDiv.textContent = message;
  messagesDiv.appendChild(messageDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// New function to display public messages
function displayPublicMessage(data) {
  const messagesDiv = document.getElementById('publicChatMessages');
  const wasAtBottom = isScrolledToBottom(messagesDiv);
  const messageDiv = document.createElement('div');
  messageDiv.className = 'message';

  const isOwnMessage = data.clientId === publicRoom.party.client.id;
  messageDiv.style.backgroundColor = isOwnMessage ? '#e3f2fd' : '#f5f5f5';
  messageDiv.style.marginLeft = isOwnMessage ? 'auto' : '0';

  const displayName = isOwnMessage ? `${data.username} (you)` : data.username;
  const timestamp = new Date(data.timestamp).toLocaleTimeString();

  messageDiv.innerHTML = `
    <strong>${displayName}</strong> <span style="color: #666; font-size: 0.8em;">${timestamp}</span><br>
    ${data.message}
  `;

  messagesDiv.appendChild(messageDiv);
  
  if (wasAtBottom) {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  } else {
    showNewMessagesIndicator('publicChatMessages');
  }
}

// New function for public system messages
function addPublicSystemMessage(message) {
  const messagesDiv = document.getElementById('publicChatMessages');
  const messageDiv = document.createElement('div');
  messageDiv.className = 'system-message';
  messageDiv.textContent = message;
  messagesDiv.appendChild(messageDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

document.getElementById('publicMessageInput').addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault(); // Prevent default to avoid newline
    sendPublicMessage();
  }
});

document.getElementById('messageInput').addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault(); // Prevent default to avoid newline
    sendMessage();
  }
});

function showNewMessagesIndicator(chatId) {
  const indicator = document.querySelector(`#${chatId}NewMessages`);
  if (indicator) {
    indicator.style.display = 'block';
  }
}

function scrollToBottom(chatId) {
  const messages = document.getElementById(chatId);
  messages.scrollTop = messages.scrollHeight;
  const indicator = document.querySelector(`#${chatId}NewMessages`);
  if (indicator) {
    indicator.style.display = 'none';
  }
}

// New function to display messages
function displayMessage(data) {
  const messages = document.getElementById('chatMessages');
  const wasAtBottom = isScrolledToBottom(messages);
  const messageDiv = document.createElement('div');
  messageDiv.className = 'message';

  const isOwnMessage = data.clientId === state.room.party.client.id;
  messageDiv.style.backgroundColor = isOwnMessage ? '#e3f2fd' : '#f5f5f5';
  messageDiv.style.marginLeft = isOwnMessage ? 'auto' : '0';

  const displayName = isOwnMessage ? `${data.username} (you)` : data.username;
  const timestamp = new Date(data.timestamp).toLocaleTimeString();

  messageDiv.innerHTML = `
    <strong>${displayName}</strong> <span style="color: #666; font-size: 0.8em;">${timestamp}</span><br>
    ${data.message}
  `;

  messages.appendChild(messageDiv);
  
  if (wasAtBottom) {
    messages.scrollTop = messages.scrollHeight;
  } else {
    showNewMessagesIndicator('chatMessages');
  }
}
</script>
</body></html>
